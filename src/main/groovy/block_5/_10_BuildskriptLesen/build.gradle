package block_5._10_BuildskriptLesen

// https://docs.gradle.org/current/userguide/writing_tasks_intermediate.html

/**
 * Aufgabe 10
 * Ihr werdet nun von oben nach unten durcharbeiten und lernen, was alles mit Tasks in Gradle möglich ist, was die Vorteile sind.
 * Es werden Fragen gestellt, gebe deine Antworten nebendran an. Führe die Tasks auch aus.
 * Als erste Frage um die Tanzbeine zu wärmen:
 * - Wo kannst du hier ELemente von Groovy (Closures, GStrings, Methoden ohne Klammern, ...) erkennen?
 */

plugins {
    id 'groovy'
    id 'application'
}

group = 'de.thm.workshop'
version = '1.0.0'

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.apache.groovy:groovy:5.0.0'
    testImplementation 'org.spockframework:spock-core:2.4-groovy-5.0'
}

application {
    mainClass = 'block_1.Main'
}

// ==============================
// Task 1: Begrüßung
// ==============================
//
// Führe `./gradlew greetTask` aus.
// Fragen:
// - Was gibt die Task aus?
// - In welchem Build-Ordner erscheinen Änderungen?
// - Welche Vorteile hat es, solche kleine Tasks zu erstellen?
tasks.register('greetTask') {
    description = "Gibt eine Begrüßung aus"
    group = "Workshop"

    doLast {
        println "Hello from Gradle"
        println "Projekt: $project.name"
        println "Version: $version"
    }
}

// ==============================
// Task 2: Dateien kopieren
// ==============================
//
// Führe `./gradlew copyWarTask` aus.
// Fragen:
// - Welche Dateien werden kopiert?
// - Aus welchem Ordner stammen sie?
// - In welchen Ordner werden sie gelegt?
// - Was passiert, wenn der Zielordner noch nicht existiert?
// - Werden alle Dateien kopiert oder nur bestimmte? Warum?
// - Was passiert, wenn du eine neue .war Datei hinzufügst und die Task erneut ausführst?
tasks.register('copyWarTask', Copy) {
    from("source")
    into("target")
    include("*.war")
}

// ==============================
// Task 3: Datei löschen
// ==============================
//
// Führe `./gradlew deleteOutputTask` aus.
// Fragen:
// - Welche Datei wird gelöscht?
// - In welchem Verzeichnis liegt sie?
// - Was passiert, wenn die Datei nicht existiert?
// - Warum ist es sinnvoll, solche Delete-Tasks im Build zu haben?
tasks.register('deleteOutputTask', Delete) {
    delete layout.buildDirectory.file("outputs/1.txt")
}

// ==============================
// Task 4: Custom DefaultTask
// ==============================
//
// Führe `./gradlew customHelloTask` aus
// Fragen:
// - Wie unterscheidet sich diese Task von Copy/Delete?
class HelloTask extends DefaultTask {
    @TaskAction
    static void hello() {
        println("hello from HelloTask")
    }
}

tasks.register("customHelloTask", HelloTask) {
    group = "Custom tasks"
    description = "Eine liebevolle Begrüßungs-Task"
}

// ==============================
// Task 5: CreateAFileTask
// ==============================
//
// Fragen:
// - Welche Datei wird erzeugt?
// - Wo wird sie erstellt?
// - Welche Annotation markiert Eingabewerte?
// - Welche markiert die Ausgabedatei?
// - Warum sind diese Annotationen wichtig?
// - Wird die Task erneut ausgeführt oder übersprungen, wenn der Text sich nicht ändert?
abstract class CreateAFileTask extends DefaultTask {
    @Input
    abstract Property<String> getFileText()

    @Input
    final String fileName = "myfile.txt"

    @OutputFile
    final File myFile = new File(fileName)

    @TaskAction
    void action() {
        myFile.createNewFile()
        myFile.text = fileText.get()
    }
}

// ==============================
// Task 6: introTask
// ==============================
//
// Führe `gradle -q intro` aus.
// Fragen:
// - Wird die introTask-Task automatisch mit ausgeführt?
// - Warum (nicht)?
// - Was bewirkt `dependsOn`?
// - In welcher Reihenfolge werden die Tasks ausgeführt?
//
// Ergänze anschließend: dependsOn tasks.introTask /
// Was ändert sich jetzt?
tasks.register('introTask') {
    doLast {
        println 'Hello world!'
    }
}
tasks.register('intro') {
    // dependsOn tasks.introTask
    doLast {
        println "I'm Gradle"
    }
}

// ==============================
// Task 7: taskX / taskY Reihenfolge
// ==============================
//
// Frage:
// Funktioniert taskX, obwohl taskY erst danach definiert wird?
// Beobachtungsaufträge:
// - Führe `./gradlew taskX` aus.
// - Welche Ausgabe erscheint zuerst?
// - Was sagt das über die Auswertungsphase von Gradle aus?
tasks.register('taskX') {
    dependsOn 'taskY'
    doLast {
        println 'taskX'
    }
}
tasks.register('taskY') {
    doLast {
        println 'taskY'
    }
}


// ==============================
// Task 8: helloWithAssemble
// ==============================
//
// Führe `./gradlew helloWithAssemble` aus.
// Fragen:
// - Welche Task wird vor helloWithAssemble ausgeführt?
// - Was macht die assemble-Task?
// - Warum könnte es sinnvoll sein, hello davon abhängig zu machen?
// - Welche Artefakte existieren danach im build-Ordner?
tasks.register('helloWithAssemble') {
    group = "Custom"
    description = "A lovely greeting task."
    doLast {
        println("Hello world!")
    }
    dependsOn(tasks.assemble)
}

// ==============================
// Task 9: helloLifecycle
// ==============================
//
// Führe `./gradlew helloLifecycle` aus.
// Fragen:
// - Welche Ausgabe erscheint in welcher Reihenfolge?
// - Welche Aktion läuft ganz am Anfang?
// - Welche ganz am Ende?
// - Was passiert, wenn du ein weiteres doFirst hinzufügst?
// - Wie verwaltet Gradle die Aktionsliste intern?
tasks.register('helloLifecycle') {
    doLast {
        println 'Hello Earth'
    }
}
tasks.named('helloLifecycle') {
    doFirst {
        println 'Hello Venus'
    }
}
tasks.named('helloLifecycle') {
    doLast {
        println 'Hello Mars'
    }
}
tasks.named('helloLifecycle') {
    doLast {
        println 'Hello Jupiter'
    }
}